### 优化展现速度

虽然说 Skeleton 本身并不能减少 First meaningful page 也就是真实页面内容出现的时间，但是本身的展示也存在白屏时间。

让我们先来看一下时间线，打开 Chrome Devtool 中性能面板：
![](https://boscdn.baidu.com/assets/lavas/codelab/skeleton.png)

不难发现，在 HTML 下载完毕之后，浏览器仍然需要等待样式（index.css）下载完毕才开始渲染骨架屏。
这是由于浏览器构建渲染树需要 DOM 和 CSSOM，因此 HTML 和 CSS 都是会阻塞渲染的资源。这在大部分场景下都是合情合理的，毕竟让用户看到内容在样式加载前后闪烁（FOUC）是需要避免的。

但是骨架屏所需的样式已经内联在 HTML 中，供前端渲染内容使用的 CSS 显然不应该阻塞骨架屏的渲染。有没有办法改变这个特性呢？

首先想到的办法是，将 `<link>` 从 `<head>` 中挪到 `<body>` 中，HTML 规范允许这样做：
> A `<link>` tag can occur either in the head element or in the body element (or both), depending on whether it has a link type that is body-ok. For example, the stylesheet link type is body-ok, and therefore a `<link rel="stylesheet">` is permitted in the body.

这样 CSS 只会阻塞后续内容，骨架屏可以不受影响地被渲染。
{% prism html linenos %}
<head>
    <style>Skeleton CSS</style>
</head>
<body>
    <div>Skeleton DOM</div>
    <link rel='stylesheet' href='index.css'>
    <div id='app'>...</div>
</body>
{% endprism %}

但是在 Chrome 中测试后会发现 CSS 依然阻塞渲染，在 Chrome 的关于这个问题的一个[讨论](https://bugs.chromium.org/p/chromium/issues/detail?id=481122)中，能看到由于针对这种情况的渲染策略并没有严格的规范，不同浏览器下出现了不同的表现：
* Chrome 依旧阻塞渲染。[Webpagetest](http://www.webpagetest.org/video/compare.php?tests=150424_57_12PJ-r:1-c:0)
* IE 符合预期，仅仅阻塞后续内容。[Webpagetest](http://www.webpagetest.org/video/compare.php?tests=150424_NH_12XE-r:1-c:0)
* Firefox 完全不阻塞渲染，除非 `<head>` 中已经出现了阻塞的 `<link>`。这样后续内容就会出现 FOUC。[Webpagetest](http://www.webpagetest.org/video/compare.php?tests=150424_MS_1297-r:1-c:0)。需要在 `<link>` 之后加上空的 `<script> </script>` 达到阻塞后续内容渲染的效果。

[loadCSS](https://github.com/filamentgroup/loadCSS) 为异步加载样式表提供了两种方式：
1. `<link ref='preload'>`
2. 提供全局 `loadCSS` 方法，动态加载指定样式表
我们将使用第一种方法，也是 loadCSS 推荐的方式。

`<link ref='preload'>` 让浏览器仅仅请求下载样式表，但完成后并不会应用样式，也就不会阻塞浏览器渲染了。如果想在下载完成后应用样式，可以在 `onload` 回调函数中修改 `rel` 的值为 `stylesheet`，像正常阻塞样式表一样应用。
另外，由于[浏览器支持度](https://caniuse.com/#feat=link-rel-preload)问题，loadCSS 提供了 [polyfill](https://github.com/filamentgroup/loadCSS/blob/master/src/cssrelpreload.js) （使用 media 属性），以及在不支持 JS 情况下降级。完整例子如下：
{% prism html linenos %}
<link rel="preload" href="path/to/mystylesheet.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="path/to/mystylesheet.css"></noscript>
<script>
/*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */
(function(){ ... }());
</script>
{% endprism %}

我们以 Vue 项目为例，首先必须要保证 Vue 实例在异步样式表加载完毕后进行[挂载](https://vuejs.org/v2/api/#vm-mount)，如果此时样式还没有完成，我们把挂载方法放到全局，等到样式加载完成后再调用：
{% prism javascript linenos %}
app = new App();
window.mountApp = () => {
    app.$mount('#app');
};
if (window.STYLE_READY) {
    window.mountApp();
}
{% endprism %}

然后使用 `<link ref='preload'>`，当加载完成时，如果发现全局有 `mountApp`，就执行挂载：
{% prism html linenos %}
<link rel='preload' href='index.css' as='style' onload='this.onload=null;this.rel='stylesheet';window.STYLE_READY=1;window.mountApp&&window.mountApp();'>
{% endprism %}

最终效果如下：
![image](https://user-images.githubusercontent.com/3608471/36834922-6e99d466-1d6f-11e8-8364-b73bc7a9dbb5.png)