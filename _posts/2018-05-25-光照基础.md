---
layout: post
title: "光照基础"
subtitle:  "WebGL Programing Guide 学习笔记"
cover: "/assets/img/webgl/logo.png"
date:   2018-05-25
category: coding
tags: WebGL
author: xiaOp
comments: true
index: 49
---

之前我们已经了解了：
* [Shader 基础知识]({{ site.baseurl }}{% link _posts/2018-04-05-Shader 基础知识.md %})
* [WebGL 3D 基础知识]({{ site.baseurl }}{% link _posts/2018-04-10-进入3D世界.md %})，包括基本的矩阵变换和观察视角

在真实世界中，物体在光线照射下的表现十分重要。这次我们就来学习下 WebGL 中光照的基础知识。

## shading

首先光线照射不光会造成“阴影”，物体表面的颜色也会发生变化，这就是 `shading`。
{% responsive_image path: assets/img/webgl/shading&shadow.png alt: "shading 和 shadow" %}

影响因素显然有两个：光源类型以及物体表面的反射情况。

### 光源类型

除了熟悉的平行光例如阳光和点光源，环境光源是光线被其他物体表面反射，再到达目标物体表面的一种光源模型。
书中举了一个很常见的例子：在夜晚打开冰箱门，整个房间都变亮了一点。
{% responsive_image path: assets/img/webgl/lighttype.png alt: "光源类型" %}

下面来看看物体表面的反射情况。

### 漫反射

{% responsive_image path: assets/img/webgl/diffuse-reflection.png alt: "漫反射" %}

漫反射表面颜色计算公式如下。当 θ 为90度也就是光源照射方向平行于物体表面，表面颜呈现黑色，这也符合我们的常识。
{% prism bash linenos %}
〈surface color by diffuse reflection〉 =
    〈light color〉 × 〈base color of surface〉 × cosθ
{% endprism %}

但是在实际应用中，θ 是很难直接得到的。相对的，光源方向和物体表面的方向很容易得到：
{% prism bash linenos %}
cosθ = 〈light direction〉 • 〈orientation of a surface〉
{% endprism %}

只要得到垂直于物体表面的法向量和光源方向向量，就能计算出 cos θ：
{% responsive_image path: assets/img/webgl/diffuse-reflection2.png alt: "cos θ 的计算" %}

这里涉及一个简单的线性代数知识，如果 n 和 l 都是单位向量，即模为 1，cos θ 就是两个向量点乘的结果：
{% prism bash linenos %}
n • l = |n| x |l| x cos θ
{% endprism %}

在 fragment shader 中，使用 GLSL ES 提供的一系列内置工具函数，应用以上公式，就可以计算出最终物体表面的颜色：
{% prism glsl linenos %}
attribute vec4 a_Color;
attribute vec4 a_Normal; // 法向量
uniform vec3 u_LightColor; // 光源颜色
uniform vec3 u_LightDirection; // 光源方向向量，标准向量
varying vec4 v_Color;

vec3 normal = normalize(a_Normal.xyz);
float nDotL = max(dot(u_LightDirection, normal), 0.0);
vec3 diffuse = u_LightColor * a_Color.rgb * nDotL;
v_Color = vec4(diffuse, a_Color.a);
{% endprism %}

这里有一个注意点，在计算光源方向和法向量的点乘结果时，我们保证了最小值为0。
这是由于当结果小于0时，说明夹角大于 90 度，光源处于物体表面的背后，颜色显然就是黑色了。

### 环境反射

在实际场景中，背对光源的表面也不一定为纯黑，来自墙壁，地面等其他物体的反射光线投到物体表面，也会使表面颜色发生改变，这就是环境反射。
{% responsive_image path: assets/img/webgl/ambient-reflection.png alt: "环境反射" %}

相比漫反射，不需要考虑光源和表面的夹角。
{% prism bash linenos %}
〈surface color by ambient reflection〉 =
    〈light color〉 × 〈base color of surface〉
{% endprism %}

加上之前的漫反射：
{% prism glsl linenos %}
uniform vec3 u_AmbientLight;
vec3 ambient = u_AmbientLight * a_Color.rgb;

v_Color = vec4(diffuse + ambient, a_Color.a);
{% endprism %}

## 法向量的计算

之前法向量都是不变的，在实际场景中，当应用了变换矩阵，做出了平移旋转缩放之后，如何通过变换矩阵计算当前的法向量呢？

这里需要使用逆转置矩阵。顾名思义，先对变换矩阵得到逆矩阵，再交换行列就得到：
{% prism javascript linenos %}
normalMatrix.setInverseOf(modelMatrix);
normalMatrix.transpose();
{% endprism %}

变换之后的法向量只要左乘逆转置矩阵即可：
{% prism glsl linenos %}
vec3 normal = normalize(vec3(u_NormalMatrix * a_Normal))
{% endprism %}

## 光线方向计算

之前在漫反射中讨论的光线方向都是一致的，换言之，对于同一个表面，接收到的是平行光。
而在实际生活中光源常常是一个物体，例如电灯泡会向四周发射光线，这样同一个表面上不同的点接收到的光线方向也就不一样了。

### per-vertex

对于每一个 vertex，需要先左乘变换矩阵得到相对世界坐标，然后与光线方向向量相减，得到该 vertex 接收到的光线方向。
{% prism glsl linenos %}
vec4 vertexPosition = u_ModelMatrix * a_Position;
vec3 lightDirection = normalize(u_LightPosition - vec3(vertexPosition));
{% endprism %}

但是仔细观察会发现这样计算出的效果存在瑕疵，尤其是在球体上十分明显。这是由于我们针对 vertex 进行计算，随后会经过线性插值得到每个 fragment 的值。

{% responsive_image path: assets/img/webgl/per-vertex.png alt: "per-vertex 计算效果" %}

### per-fragment

因此为了得到更真实的渲染效果，需要针对每个 fragment 进行计算。
这就需要将 shading 计算逻辑从 vertex shader 中挪到 fragment shader 中。

在[Shader 基础知识]({{ site.baseurl }}{% link _posts/2018-04-05-Shader 基础知识.md %})中，我们知道在两个 shader 之间传递变量需要用到 varying。

在 vertex shader 中计算好法向量，连同物体表面颜色一起传递过去。
有一点需要注意，计算出的 vertex 坐标也就是 `v_Position` 在到达 fragment shader 前会先经过线性插值，毕竟 vertex 比 fragment 数量少的多得多。
{% prism glsl linenos %}
v_Position = vec3(u_ModelMatrix * a_Position);
v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));
v_Color = a_Color;
{% endprism %}

真正的计算放在 fragment shader 中，这里的 `v_Position` 已经是线性插值之后的了。
`v_Normal` 和 `v_Color` 也是一样：
{% prism glsl linenos %}
vec3 normal = normalize(v_Normal);
vec3 lightDirection = normalize(u_LightPosition - v_Position);
float nDotL = max(dot(lightDirection, normal), 0.0);
vec3 diffuse = u_LightColor * v_Color.rgb * nDotL;
vec3 ambient = u_AmbientLight * v_Color.rgb;
gl_FragColor = vec4(diffuse + ambient, v_Color.a);
{% endprism %}

## 总结

现在我们知道了光线照射下物体表面颜色的计算方法。是时候将多个简单 3D 对象组合成一个复杂物体了。